package bot

import (
"errors"
	"fmt"
	"reflect"
	"sort"
"strings"
	"sync"
"testing"
	"time"
)

var (
channel     string
	replies     chan string
	cmdError    chan string
user        *User
	msgs        []string
errs        []string
protoParams interface{}
)

const (
expectedMsg    = "msg"
	cmd            = "cmd"
cmdDescription = "Command description"
cmdExampleArgs = "arg1 arg2"
)

func waitMessages(t *testing.T, count int, errorCount int) {
for {
		select {
case reply := <-replies:
msgs = append(msgs, reply)
		case err := <-cmdError:
errs = append(errs, err)
		case <-time.After(1 * time.Second):
t.Error("Timeout waiting for messages")
t.Errorf("msgs received: %v", msgs)
			t.Errorf("errs received: %v", errs)
t.Fatal()
		}
if len(msgs) == count && len(errs) == errorCount {
			return
}
	}
}

func responseHandler(target string, message string, sender *User) {
channel = target
	user = sender
	replies <- message
}

func responseHandlerV2(om OutgoingMessage) {
	channel = om.Target
user = om.Sender
	protoParams = om.ProtoParams
replies <- om.Message
}

func errorHandler(msg string, err error) {
	cmdError <- fmt.Sprintf("%s: %s", msg, err)
}

func reset() {
	channel = ""
user = &User{Nick: ""}
replies = make(chan string, 10)
cmdError = make(chan string, 10)
msgs = []string{}
errs = []string{}
	protoParams = nil
commands = make(map[string]*customCommand)
	periodicCommands = make(map[string]PeriodicConfig)
passiveCommands = make(map[string]*customCommand)
filterCommands = make(map[string]*customCommand)
}
